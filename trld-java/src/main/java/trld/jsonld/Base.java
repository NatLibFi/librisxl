/**
 * This file was automatically generated by the TRLD transpiler.
 * Source: trld/jsonld/base.py
 */
package trld.jsonld;

//import javax.annotation.Nullable;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.io.*;

import trld.Builtins;
import trld.KeyValue;


public class Base {
  public static final Set<String> PREFIX_DELIMS = new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) ":", "/", "?", "#", "[", "]", "@"}))); // LINE: 13
  public static final String BASE = "@base"; // LINE: 15
  public static final String CONTAINER = "@container"; // LINE: 16
  public static final String CONTEXT = "@context"; // LINE: 17
  public static final String DIRECTION = "@direction"; // LINE: 18
  public static final String GRAPH = "@graph"; // LINE: 19
  public static final String ID = "@id"; // LINE: 20
  public static final String IMPORT = "@import"; // LINE: 21
  public static final String INCLUDED = "@included"; // LINE: 22
  public static final String INDEX = "@index"; // LINE: 23
  public static final String JSON = "@json"; // LINE: 24
  public static final String LANGUAGE = "@language"; // LINE: 25
  public static final String LIST = "@list"; // LINE: 26
  public static final String NEST = "@nest"; // LINE: 27
  public static final String NONE = "@none"; // LINE: 28
  public static final String PREFIX = "@prefix"; // LINE: 29
  public static final String PROPAGATE = "@propagate"; // LINE: 30
  public static final String PROTECTED = "@protected"; // LINE: 31
  public static final String REVERSE = "@reverse"; // LINE: 32
  public static final String SET = "@set"; // LINE: 33
  public static final String TYPE = "@type"; // LINE: 34
  public static final String VALUE = "@value"; // LINE: 35
  public static final String VERSION = "@version"; // LINE: 36
  public static final String VOCAB = "@vocab"; // LINE: 37
  public static final String ANY = "@any"; // LINE: 40
  public static final String NULL = "@null"; // LINE: 41
  public static final String DEFAULT = "@default"; // LINE: 42
  public static final Set</*@Nullable*/ String> NULLS = new HashSet(new ArrayList<>(Arrays.asList(new Object[] {(Object) null, NULL}))); // LINE: 45
  public static final Set</*@Nullable*/ String> NOTHING = new HashSet(new ArrayList<>(Arrays.asList(new Object[] {(Object) null, NULL, NONE}))); // LINE: 46
  public static final Set<String> KEYWORDS = new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) BASE, CONTAINER, CONTEXT, DIRECTION, GRAPH, ID, IMPORT, INCLUDED, INDEX, JSON, LANGUAGE, LIST, NEST, NONE, PREFIX, PROPAGATE, PROTECTED, REVERSE, SET, TYPE, VALUE, VERSION, VOCAB}))); // LINE: 48
  public static final Set<String> CONTEXT_KEYWORDS = new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) VERSION, IMPORT, BASE, VOCAB, LANGUAGE, DIRECTION, PROPAGATE, PROTECTED}))); // LINE: 74
  public static final Set<String> VALUE_KEYWORDS = new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) DIRECTION, INDEX, LANGUAGE, TYPE, VALUE}))); // LINE: 85
  public static final Set<String> CONTAINER_KEYWORDS = new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) GRAPH, ID, INDEX, LANGUAGE, LIST, SET, TYPE}))); // LINE: 89
  public static final Set<String> DIRECTIONS = new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) "rtl", "ltr"}))); // LINE: 91
  public static final String JSONLD10 = "json-ld-1.0"; // LINE: 93
  public static final String JSONLD11 = "json-ld-1.1"; // LINE: 94

  public static boolean isIri(/*@Nullable*/ String value) { // LINE: 101
    return (value != null && value.contains(":") && isIriRef(value)); // LINE: 102
  }

  public static boolean isIriRef(/*@Nullable*/ String value) { // LINE: 105
    /* ... */; // LINE: 106
    return (value != null && !value.contains(" ") && !(isBlank(value))); // LINE: 107
  }

  public static boolean isBlank(String value) { // LINE: 110
    /* ... */; // LINE: 111
    return value.startsWith("_:"); // LINE: 112
  }

  public static boolean hasKeywordForm(String s) { // LINE: 115
    return (s.startsWith("@") && s.substring(1).matches("^\\w+$")); // LINE: 116
  }

  public static boolean isLangTag(/*@Nullable*/ String value) { // LINE: 119
    /* ... */; // LINE: 120
    return (value != null && value.substring(0, 0 + 1).matches("^\\w+$") && !value.contains(" ")); // LINE: 121
  }

  public static boolean isScalar(Object o) { // LINE: 125
    return o instanceof String || o instanceof Integer || o instanceof Double || o instanceof Boolean; // LINE: 126
  }

  public static boolean isGraphObject(Map<String, Object> o) { // LINE: 129
    if (o.containsKey(GRAPH)) { // LINE: 130
      if (o.containsKey(ID)) { // LINE: 131
        if (o.containsKey(INDEX)) { // LINE: 132
          return o.size() == 3; // LINE: 133
        }
        return o.size() == 2; // LINE: 134
      }
      if (o.containsKey(INDEX)) { // LINE: 135
        return o.size() == 2; // LINE: 136
      }
      return o.size() == 1; // LINE: 137
    }
    return false; // LINE: 138
  }

  public static boolean isSimpleGraphObject(Map<String, Object> o) { // LINE: 141
    if (o.containsKey(GRAPH)) { // LINE: 142
      return (o.containsKey(INDEX) ? o.size() == 2 : o.size() == 1); // LINE: 143
    }
    return false; // LINE: 144
  }

  public static void addValueAsList(Map map, String key, Object value) { // LINE: 147
    addValue(map, key, value, true); // LINE: 148
  }

  public static void addValue(Map map, String key, Object value) {
    addValue(map, key, value, false);
  }
  public static void addValue(Map map, String key, Object value, Boolean aslist) { // LINE: 151
    Object existing = (Object) map.get(key); // LINE: 153
    if ((aslist && !map.containsKey(key))) { // LINE: 154
      map.put(key, asList(value)); // LINE: 155
    } else if (!map.containsKey(key)) { // LINE: 160
      map.put(key, value); // LINE: 161
    } else {
      if (!(existing instanceof List)) { // LINE: 163
        map.put(key, new ArrayList<>(Arrays.asList(new Object[] {(Object) existing}))); // LINE: 164
      }
      if (value instanceof List) { // LINE: 165
        ((List) map.get(key)).addAll((List) value);
      } else {
        assert map instanceof Map;
        Object values = (Object) ((Map) map).get(key); // LINE: 169
        assert values instanceof List;
        assert value instanceof Object;
        ((List) values).add((Object) value); // LINE: 172
      }
    }
  }

  public static List asList(Object obj) { // LINE: 175
    return (obj instanceof List ? (List) obj : new ArrayList<>(Arrays.asList(new Object[] {(Object) obj}))); // LINE: 176
  }

  public static String relativiseIri(String base, String iri) { // LINE: 179
    if (iri.startsWith(base + "#")) { // LINE: 180
      return iri.substring(base.length()); // LINE: 181
    }
    if ((iri.contains("?") && iri.startsWith(base))) { // LINE: 182
      return iri.substring(base.length()); // LINE: 183
    }
    if (!(base.endsWith("/"))) { // LINE: 184
      Integer last = (Integer) base.lastIndexOf("/"); // LINE: 185
      base = base.substring(0, last + 1); // LINE: 186
    }
    if (iri.startsWith(base)) { // LINE: 187
      return iri.substring(base.length()); // LINE: 188
    }
    String parentbase = base.substring(0, base.lastIndexOf("/")); // LINE: 190
    String leaf = iri.substring(iri.lastIndexOf("/") + 1); // LINE: 191
    List<String> relativeto = new ArrayList<>(); // LINE: 192
    while ((parentbase.contains("/") && !(parentbase.endsWith(":/")))) { // LINE: 193
      if (iri.startsWith(parentbase)) { // LINE: 194
        relativeto.add(leaf); // LINE: 195
        return String.join("/", relativeto); // LINE: 196
      }
      relativeto.add(".."); // LINE: 197
      parentbase = parentbase.substring(0, parentbase.lastIndexOf("/")); // LINE: 198
    }
    return iri; // LINE: 200
  }

  public static boolean nodeEquals(Object a, Object b) { // LINE: 203
    if (isScalar(a)) { // LINE: 204
      return ((a.getClass() == null && ((Object) b.getClass()) == null || a.getClass() != null && (a.getClass()).equals(b.getClass())) && (a == null && ((Object) b) == null || a != null && (a).equals(b))); // LINE: 205
    }
    if (a instanceof List) { // LINE: 206
      if (!(b instanceof List)) { // LINE: 207
        return false; // LINE: 208
      }
      Integer i = 0; // LINE: 211
      for (Object ai : (List) a) { // LINE: 212
        if (!(nodeEquals(ai, ((List) b).get(i)))) { // LINE: 213
          return false; // LINE: 214
        }
        i += 1;
      }
      return true; // LINE: 216
    } else if (a instanceof Map) { // LINE: 217
      if (!(b instanceof Map)) { // LINE: 218
        return false; // LINE: 219
      }
      return ((Map) a).keySet().stream().allMatch(k -> (((Map) b).containsKey(k) && nodeEquals(((Map) a).get(k), ((Map) b).get(k)))); // LINE: 220
    } else {
      return false; // LINE: 222
    }
  }
}
