/**
 * This file was automatically generated by the TRLD transpiler.
 * Source: trld/trig/parser.py
 */
package trld.trig;

//import javax.annotation.Nullable;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.io.*;

import trld.Builtins;
import trld.KeyValue;

import trld.Input;
import static trld.Common.dumpJson;
import static trld.jsonld.Base.VALUE;
import static trld.jsonld.Base.TYPE;
import static trld.jsonld.Base.LANGUAGE;
import static trld.jsonld.Base.ID;
import static trld.jsonld.Base.LIST;
import static trld.jsonld.Base.GRAPH;
import static trld.jsonld.Base.CONTEXT;
import static trld.jsonld.Base.VOCAB;
import static trld.jsonld.Base.BASE;
import static trld.jsonld.Base.PREFIX;
import static trld.jsonld.Base.PREFIX_DELIMS;
import static trld.Rdfterms.RDF_TYPE;
import static trld.Rdfterms.XSD;
import static trld.Rdfterms.XSD_DOUBLE;
import static trld.Rdfterms.XSD_INTEGER;
import static trld.trig.Parser.*;


public class ReadNodes extends ReadNode { // LINE: 712
  ReadNodes(/*@Nullable*/ ParserState parent) { super(parent); };
  public List<Map> nodes; // LINE: 714
  public Boolean expectGraph; // LINE: 715

  public void init() { // LINE: 717
    this.nodes = new ArrayList<>(); // LINE: 718
    this.reset(); // LINE: 719
  }

  public void reset() { // LINE: 721
    this.node = null; // LINE: 722
    this.p = null; // LINE: 723
    this.lastValue = null; // LINE: 724
    this.expectGraph = false; // LINE: 725
  }

  public Map.Entry<ParserState, Object> consume(String c, Object prevValue) { // LINE: 727
    if (prevValue != null) { // LINE: 728
      if (prevValue instanceof String) { // LINE: 729
        Boolean finalDot = false; // LINE: 730
        if (AT_KEYWORDS.contains(prevValue)) { // LINE: 731
          prevValue = ((String) prevValue).substring(1); // LINE: 732
          finalDot = true; // LINE: 733
        }
        if ((prevValue == null && ((Object) RQ_PREFIX) == null || prevValue != null && (prevValue).equals(RQ_PREFIX))) { // LINE: 734
          return new ReadPrefix(this, finalDot).consume(c, null); // LINE: 735
        } else if ((prevValue == null && ((Object) RQ_BASE) == null || prevValue != null && (prevValue).equals(RQ_BASE))) { // LINE: 736
          return new ReadBase(this, finalDot).consume(c, null); // LINE: 737
        } else if ((prevValue == null && ((Object) RQ_GRAPH) == null || prevValue != null && (prevValue).equals(RQ_GRAPH))) { // LINE: 738
          this.expectGraph = true; // LINE: 739
          return new KeyValue(this, null); // LINE: 740
        }
      }
      if (this.node == null) { // LINE: 742
        assert prevValue instanceof Map;
        this.node = (Map) this.nodeWithId((Map) prevValue); // LINE: 744
      } else {
        if ((this.p == null && this.expectGraph && this.node != null)) { // LINE: 746
          throw new NotationError("Expected graph notation to follow, got " + prevValue); // LINE: 747
        }
        this.fillNode(prevValue); // LINE: 749
      }
    }
    if ((c == null && ((Object) EOF) == null || c != null && (c).equals(EOF))) { // LINE: 751
      Map<String, Object> result = Builtins.mapOf(CONTEXT, this.context, GRAPH, this.nodes); // LINE: 752
      return new KeyValue(this.parent, result); // LINE: 753
    } else if (((c == null && ((Object) ".") == null || c != null && (c).equals(".")) && (this.p == null || this.lastValue != null))) { // LINE: 754
      this.nextNode(); // LINE: 755
      return new KeyValue(this, null); // LINE: 756
    } else {
      if (this.openBrace) { // LINE: 758
        if (!c.equals("|")) { // LINE: 759
          this.openBrace = false; // LINE: 760
          this.expectGraph = false; // LINE: 761
          ReadGraph state = new ReadGraph(this); // LINE: 762
          return state.consume(c, prevValue); // LINE: 763
        }
      }
      return this.consumeNodeChar(c); // LINE: 764
    }
  }

  public void nextNode() { // LINE: 766
    if ((this.node == null || (this.p == null && (!this.node.containsKey(GRAPH) && (this.node.containsKey(ID) && this.node.size() == 1))))) { // LINE: 767
      throw new NotationError("Incomplete triple for node: " + this.node); // LINE: 770
    }
    this.nodes.add(this.node); // LINE: 771
    this.reset(); // LINE: 772
  }
}
