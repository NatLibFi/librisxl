/**
 * This file was automatically generated by the TRLD transpiler.
 * Source: trld/trig/parser.py
 */
package trld.trig;

//import javax.annotation.Nullable;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.io.*;

import trld.Builtins;
import trld.KeyValue;

import trld.Input;
import static trld.Common.dumpJson;
import static trld.jsonld.Base.VALUE;
import static trld.jsonld.Base.TYPE;
import static trld.jsonld.Base.LANGUAGE;
import static trld.jsonld.Base.ID;
import static trld.jsonld.Base.LIST;
import static trld.jsonld.Base.GRAPH;
import static trld.jsonld.Base.CONTEXT;
import static trld.jsonld.Base.VOCAB;
import static trld.jsonld.Base.BASE;
import static trld.jsonld.Base.PREFIX;
import static trld.jsonld.Base.PREFIX_DELIMS;
import static trld.Rdfterms.RDF_TYPE;
import static trld.Rdfterms.XSD;
import static trld.Rdfterms.XSD_DOUBLE;
import static trld.Rdfterms.XSD_INTEGER;
import static trld.trig.Parser.*;


public class ReadLiteral extends ReadTerm { // LINE: 347
  public /*@Nullable*/ String value; // LINE: 349
  public String quotechar; // LINE: 350
  public Integer multiline; // LINE: 351
  public Integer prevDtStart; // LINE: 352

  public ReadLiteral(ParserState parent, String quotechar) { // LINE: 354
    super(parent); // LINE: 355
    this.quotechar = quotechar; // LINE: 356
    this.escapeChars = ESC_CHARS; // LINE: 357
  }

  public void init() { // LINE: 359
    this.prevDtStart = 0; // LINE: 360
    this.value = null; // LINE: 361
    this.multiline = 0; // LINE: 362
  }

  public Map.Entry<ParserState, Object> consume(String c, Object prevValue) { // LINE: 364
    if (((this.value == null && ((Object) "") == null || this.value != null && (this.value).equals("")) && (c == null && ((Object) this.quotechar) == null || c != null && (c).equals(this.quotechar)))) { // LINE: 365
      this.multiline = 1; // LINE: 366
      this.value = null; // LINE: 367
      return new KeyValue(this, null); // LINE: 368
    } else if (this.value != null) { // LINE: 369
      if (this.prevDtStart > 0) { // LINE: 370
        this.noAfterLiteral("Datatype", prevValue); // LINE: 371
        if ((c == null && ((Object) "^") == null || c != null && (c).equals("^"))) { // LINE: 372
          assert this.prevDtStart == 1;
          this.prevDtStart = 2; // LINE: 374
          return new KeyValue(this, null); // LINE: 375
        } else {
          assert this.prevDtStart == 2;
          this.prevDtStart = 0; // LINE: 378
          return new ReadSymbol(this).consume(c, null); // LINE: 379
        }
      }
      if ((c == null && ((Object) "^") == null || c != null && (c).equals("^"))) { // LINE: 381
        this.noAfterLiteral("Datatype", prevValue); // LINE: 382
        this.prevDtStart = 1; // LINE: 383
        return new KeyValue(this, null); // LINE: 384
      }
      if ((c == null && ((Object) "@") == null || c != null && (c).equals("@"))) { // LINE: 386
        this.noAfterLiteral("Language", prevValue); // LINE: 387
        ReadLanguage state = new ReadLanguage(this); // LINE: 388
        return new KeyValue(new ReadLanguage(this), null); // LINE: 389
      }
      Map<String, String> value = Builtins.mapOf(VALUE, this.value); // LINE: 391
      if (prevValue != null) { // LINE: 392
        if ((prevValue instanceof Map && ((Map) prevValue).containsKey(LANGUAGE))) { // LINE: 393
          value.putAll((Map) prevValue); // LINE: 394
        } else {
          assert prevValue instanceof Map;
          value.put(TYPE, this.symbol((Map) prevValue)); // LINE: 397
        }
      }
      return this.parent.consume(c, value); // LINE: 399
    }
    if (this.handleEscape(c)) { // LINE: 401
      return new KeyValue(this, null); // LINE: 402
    }
    if ((c == null && ((Object) this.quotechar) == null || c != null && (c).equals(this.quotechar))) { // LINE: 404
      if ((this.multiline == 0 || this.multiline == 3)) { // LINE: 405
        this.multiline = 0; // LINE: 406
        this.value = (String) this.pop(); // LINE: 407
      } else if (this.multiline > 0) { // LINE: 408
        this.multiline += 1;
      }
      return new KeyValue(this, null); // LINE: 410
    }
    if (this.multiline > 1) { // LINE: 412
      for (int i = 0; i < this.multiline - 1; i++) { // LINE: 413
        this.collect(this.quotechar); // LINE: 414
      }
      this.multiline = 1; // LINE: 415
    }
    this.collect(c); // LINE: 417
    return new KeyValue(this, null); // LINE: 418
  }

  public void noAfterLiteral(Object kind, Object prevValue) { // LINE: 420
    if (prevValue != null) { // LINE: 421
      throw new NotationError(kind + " not allowed after " + prevValue); // LINE: 422
    }
  }
}
