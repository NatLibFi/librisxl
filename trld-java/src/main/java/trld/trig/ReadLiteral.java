/**
 * This file was automatically generated by the TRLD transpiler.
 * Source: trld/trig/parser.py
 */
package trld.trig;

//import javax.annotation.Nullable;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.io.*;

import trld.Builtins;
import trld.KeyValue;

import trld.Input;
import static trld.Common.dumpJson;
import static trld.jsonld.Base.VALUE;
import static trld.jsonld.Base.TYPE;
import static trld.jsonld.Base.LANGUAGE;
import static trld.jsonld.Base.ID;
import static trld.jsonld.Base.LIST;
import static trld.jsonld.Base.GRAPH;
import static trld.jsonld.Base.CONTEXT;
import static trld.jsonld.Base.VOCAB;
import static trld.jsonld.Base.BASE;
import static trld.jsonld.Base.PREFIX;
import static trld.jsonld.Base.PREFIX_DELIMS;
import static trld.Rdfterms.RDF_TYPE;
import static trld.Rdfterms.XSD;
import static trld.Rdfterms.XSD_DOUBLE;
import static trld.Rdfterms.XSD_INTEGER;
import static trld.trig.Parser.*;


public class ReadLiteral extends ReadTerm { // LINE: 345
  public /*@Nullable*/ String value; // LINE: 347
  public String quotechar; // LINE: 348
  public Integer multiline; // LINE: 349
  public Integer prevDtStart; // LINE: 350

  public ReadLiteral(ParserState parent, String quotechar) { // LINE: 352
    super(parent); // LINE: 353
    this.quotechar = quotechar; // LINE: 354
    this.escapeChars = ESC_CHARS; // LINE: 355
  }

  public void init() { // LINE: 357
    this.prevDtStart = 0; // LINE: 358
    this.value = null; // LINE: 359
    this.multiline = 0; // LINE: 360
  }

  public Map.Entry<ParserState, Object> consume(String c, Object prevValue) { // LINE: 362
    if (((this.value == null && ((Object) "") == null || this.value != null && (this.value).equals("")) && (c == null && ((Object) this.quotechar) == null || c != null && (c).equals(this.quotechar)))) { // LINE: 363
      this.multiline = 1; // LINE: 364
      this.value = null; // LINE: 365
      return new KeyValue(this, null); // LINE: 366
    } else if (this.value != null) { // LINE: 367
      if (this.prevDtStart > 0) { // LINE: 368
        this.noAfterLiteral("Datatype", prevValue); // LINE: 369
        if ((c == null && ((Object) "^") == null || c != null && (c).equals("^"))) { // LINE: 370
          assert this.prevDtStart == 1;
          this.prevDtStart = 2; // LINE: 372
          return new KeyValue(this, null); // LINE: 373
        } else {
          assert this.prevDtStart == 2;
          this.prevDtStart = 0; // LINE: 376
          return new ReadSymbol(this).consume(c, null); // LINE: 377
        }
      }
      if ((c == null && ((Object) "^") == null || c != null && (c).equals("^"))) { // LINE: 379
        this.noAfterLiteral("Datatype", prevValue); // LINE: 380
        this.prevDtStart = 1; // LINE: 381
        return new KeyValue(this, null); // LINE: 382
      }
      if ((c == null && ((Object) "@") == null || c != null && (c).equals("@"))) { // LINE: 384
        this.noAfterLiteral("Language", prevValue); // LINE: 385
        ReadLanguage state = new ReadLanguage(this); // LINE: 386
        return new KeyValue(new ReadLanguage(this), null); // LINE: 387
      }
      Map<String, String> value = Builtins.mapOf(VALUE, this.value); // LINE: 389
      if (prevValue != null) { // LINE: 390
        if ((prevValue instanceof Map && ((Map) prevValue).containsKey(LANGUAGE))) { // LINE: 391
          value.putAll((Map) prevValue); // LINE: 392
        } else {
          assert prevValue instanceof Map;
          value.put(TYPE, this.symbol((Map) prevValue)); // LINE: 395
        }
      }
      return this.parent.consume(c, value); // LINE: 397
    }
    if (this.handleEscape(c)) { // LINE: 399
      return new KeyValue(this, null); // LINE: 400
    }
    if ((c == null && ((Object) this.quotechar) == null || c != null && (c).equals(this.quotechar))) { // LINE: 402
      if ((this.multiline == 0 || this.multiline == 3)) { // LINE: 403
        this.multiline = 0; // LINE: 404
        this.value = (String) this.pop(); // LINE: 405
      } else if (this.multiline > 0) { // LINE: 406
        this.multiline += 1;
      }
      return new KeyValue(this, null); // LINE: 408
    }
    if (this.multiline > 1) { // LINE: 410
      for (int i = 0; i < this.multiline - 1; i++) { // LINE: 411
        this.collect(this.quotechar); // LINE: 412
      }
      this.multiline = 1; // LINE: 413
    }
    this.collect(c); // LINE: 415
    return new KeyValue(this, null); // LINE: 416
  }

  public void noAfterLiteral(Object kind, Object prevValue) { // LINE: 418
    if (prevValue != null) { // LINE: 419
      throw new NotationError(kind + " not allowed after " + prevValue); // LINE: 420
    }
  }
}
