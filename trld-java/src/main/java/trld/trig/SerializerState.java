/**
 * This file was automatically generated by the TRLD transpiler.
 * Source: trld/trig/serializer.py
 */
package trld.trig;

//import javax.annotation.Nullable;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.io.*;

import trld.Builtins;
import trld.KeyValue;

import trld.Output;
import static trld.Common.uuid4;
import static trld.jsonld.Base.BASE;
import static trld.jsonld.Base.CONTAINER;
import static trld.jsonld.Base.CONTEXT;
import static trld.jsonld.Base.GRAPH;
import static trld.jsonld.Base.ID;
import static trld.jsonld.Base.INDEX;
import static trld.jsonld.Base.LANGUAGE;
import static trld.jsonld.Base.LIST;
import static trld.jsonld.Base.PREFIX;
import static trld.jsonld.Base.REVERSE;
import static trld.jsonld.Base.TYPE;
import static trld.jsonld.Base.VALUE;
import static trld.jsonld.Base.VOCAB;
import static trld.trig.Serializer.*;


public class SerializerState { // LINE: 68
  public Settings settings; // LINE: 69
  public Output out; // LINE: 70
  public /*@Nullable*/ SerializerState parent; // LINE: 71
  public Map<String, Object> context; // LINE: 72
  public /*@Nullable*/ String baseIri; // LINE: 73
  public Map<String, String> prefixes; // LINE: 74
  public KeyAliases aliases; // LINE: 75
  public /*@Nullable*/ String bnodeSkolemBase = null; // LINE: 76
  public String prefixKeyword; // LINE: 77
  public String baseKeyword; // LINE: 78
  public /*@Nullable*/ String graphKeyword = null; // LINE: 79
  public String uniqueBnodeSuffix; // LINE: 80
  public Integer bnodeCounter; // LINE: 81

  public SerializerState(Output out, Settings settings, /*@Nullable*/ Object context) {
    this(out, settings, context, null);
  }
  public SerializerState(Output out, Settings settings, /*@Nullable*/ Object context, /*@Nullable*/ String baseIri) {
    this(out, settings, context, baseIri, null);
  }
  public SerializerState(Output out, Settings settings, /*@Nullable*/ Object context, /*@Nullable*/ String baseIri, SerializerState parent) { // LINE: 83
    this.out = (out != null ? out : ((SerializerState) parent).out); // LINE: 91
    this.initContext(context); // LINE: 92
    this.baseIri = baseIri; // LINE: 93
    this.parent = parent; // LINE: 94
    this.settings = (parent != null ? parent.settings : settings); // LINE: 95
    this.prefixKeyword = (String) this.kw("prefix"); // LINE: 96
    this.baseKeyword = (String) this.kw("base"); // LINE: 97
    if (this.settings.useGraphKeyword) { // LINE: 98
      this.graphKeyword = (String) this.kw("graph"); // LINE: 99
    }
    this.uniqueBnodeSuffix = ""; // LINE: 100
    this.bnodeCounter = 0; // LINE: 101
  }

  protected String kw(String s) { // LINE: 103
    return (this.settings.upcaseKeywords ? s.toUpperCase() : s); // LINE: 104
  }

  public void initContext(/*@Nullable*/ Object context) { // LINE: 106
    this.aliases = new KeyAliases(); // LINE: 107
    this.context = new HashMap<>(); // LINE: 108
    if (context != null) { // LINE: 109
      for (String key : this.context.keySet()) { // LINE: 110
        throw new RuntimeException("context already initialized"); // LINE: 111
      }
    }
    Map<String, Object> ctx = new HashMap<>(); // LINE: 112
    if (context instanceof List) { // LINE: 114
      for (Object item : (List) context) { // LINE: 115
        ctx.putAll(((Map<String, Object>) item)); // LINE: 116
      }
    } else if (context instanceof Map) { // LINE: 117
      ctx.putAll((Map) context); // LINE: 118
    }
    this.context = ctx; // LINE: 119
    this.prefixes = (Map<String, String>) collectPrefixes(ctx); // LINE: 120
  }

  public void serialize(Object data) { // LINE: 122
    if (data instanceof Map) { // LINE: 123
      this.initContext(((Map) data).get(CONTEXT)); // LINE: 124
      this.prelude(this.prefixes); // LINE: 125
      this.writeObject((Map) data); // LINE: 126
    } else {
      assert data instanceof List;
      for (Object item : (List) data) { // LINE: 129
        this.writeObject(item); // LINE: 130
      }
    }
  }

  public void prelude(Map<String, String> prefixes) { // LINE: 132
    for (Map.Entry<String, String> k_v : prefixes.entrySet()) { // LINE: 133
      String k = k_v.getKey();
      String v = k_v.getValue();
      if ((k == null && ((Object) BASE) == null || k != null && (k).equals(BASE))) { // LINE: 134
        this.writeBase(v); // LINE: 135
      } else {
        this.writeln(this.prefixKeyword + " " + k + ": <" + v + ">"); // LINE: 137
      }
    }
    if (this.baseIri != null) { // LINE: 138
      this.writeBase(this.baseIri); // LINE: 139
    }
    if (this.settings.prologueEndLine > 1) { // LINE: 140
      this.writeln(); // LINE: 141
    }
  }

  public void writeBase(String iri) { // LINE: 143
    this.writeln(this.baseKeyword + " <" + iri + ">"); // LINE: 144
  }

  public boolean isListContainer(String term) { // LINE: 146
    if (this.context != null) { // LINE: 147
      Object termdef = (Object) this.context.get(term); // LINE: 148
      if (termdef instanceof Map) { // LINE: 149
        return (((Map) termdef).get(CONTAINER) == null && ((Object) LIST) == null || ((Map) termdef).get(CONTAINER) != null && (((Map) termdef).get(CONTAINER)).equals(LIST)); // LINE: 150
      }
    }
    return false; // LINE: 152
  }

  public boolean isLangContainer(String term) { // LINE: 154
    if (this.context != null) { // LINE: 155
      Object termdef = (Object) this.context.get(term); // LINE: 156
      if (termdef instanceof Map) { // LINE: 157
        return (((Map) termdef).get(CONTAINER) == null && ((Object) LANGUAGE) == null || ((Map) termdef).get(CONTAINER) != null && (((Map) termdef).get(CONTAINER)).equals(LANGUAGE)); // LINE: 158
      }
    }
    return false; // LINE: 160
  }

  public void writeGraph(/*@Nullable*/ String iri, Object graph) {
    this.writeGraph(iri, graph, 0);
  }
  public void writeGraph(/*@Nullable*/ String iri, Object graph, Integer depth) { // LINE: 162
    if ((iri != null && this.settings.turtleDropNamed)) { // LINE: 163
      return; // LINE: 164
    }
    Boolean inGraphBlock = (iri != null || depth > 0); // LINE: 166
    if (!(this.settings.turtleOnly)) { // LINE: 168
      if (iri == null) { // LINE: 169
        if (depth > 0) { // LINE: 170
          this.writeln(); // LINE: 171
          this.writeln("{"); // LINE: 172
        }
      } else {
        this.writeln(); // LINE: 174
        if (this.graphKeyword != null) { // LINE: 175
          this.write(this.graphKeyword + " "); // LINE: 176
        }
        this.writeln(this.refRepr(iri) + " {"); // LINE: 177
      }
    }
    for (Object node : asList(graph)) { // LINE: 179
      /*@Nullable*/ String via = (inGraphBlock ? this.aliases.graph : null); // LINE: 180
      this.writeObject(((Map<String, Object>) node), depth, via); // LINE: 181
    }
    if (!(this.settings.turtleOnly)) { // LINE: 183
      if (inGraphBlock) { // LINE: 184
        this.writeln(); // LINE: 185
        this.writeln("}"); // LINE: 186
      }
    }
  }

  public List<Map<String, Object>> writeObject(Object obj) {
    return this.writeObject(obj, 0);
  }
  public List<Map<String, Object>> writeObject(Object obj, Integer depth) {
    return this.writeObject(obj, depth, null);
  }
  public List<Map<String, Object>> writeObject(Object obj, Integer depth, /*@Nullable*/ String viaKey) { // LINE: 188
    if ((depth > 0 && obj instanceof Map && ((Map) obj).containsKey(CONTEXT))) { // LINE: 194
      throw new RuntimeException("Nested context not supported yet"); // LINE: 196
    }
    if ((viaKey != null && this.isLangContainer(viaKey) && obj instanceof Map)) { // LINE: 198
      Boolean first = true; // LINE: 199
      for (Map.Entry<String, Object> lang_value : ((Map<String, Object>) obj).entrySet()) { // LINE: 200
        String lang = lang_value.getKey();
        Object value = lang_value.getValue();
        if (!(first)) { // LINE: 201
          this.write(" , "); // LINE: 202
        }
        this.toLiteral(Builtins.mapOf(this.aliases.value, value, this.aliases.lang, lang), viaKey); // LINE: 203
        first = false; // LINE: 206
      }
      return new ArrayList<>(); // LINE: 207
    }
    if ((!(obj instanceof Map) || ((Map) obj).containsKey(this.aliases.value))) { // LINE: 209
      this.toLiteral(((Object) obj), viaKey); // LINE: 210
      return new ArrayList<>(); // LINE: 211
    }
    Boolean explicitList = (Boolean) ((Map) obj).containsKey(this.aliases.list); // LINE: 213
    if ((viaKey != null && this.isListContainer(viaKey))) { // LINE: 215
      obj = Builtins.mapOf(this.aliases.list, obj); // LINE: 216
    }
    /*@Nullable*/ String s = (/*@Nullable*/ String) ((/*@Nullable*/ String) ((Map) obj).get(this.aliases.id)); // LINE: 218
    Boolean isList = (Boolean) ((Map) obj).containsKey(this.aliases.list); // LINE: 220
    Boolean startedList = isList; // LINE: 221
    Boolean isBracketed = (Boolean) (isList || (viaKey == null && ((Object) this.aliases.annotation) == null || viaKey != null && (viaKey).equals(this.aliases.annotation))); // LINE: 223
    if (((Map) obj).containsKey(this.aliases.graph)) { // LINE: 225
      if ((s != null && this.settings.turtleDropNamed)) { // LINE: 226
        return new ArrayList<>(); // LINE: 227
      }
      if ((((Map) obj).containsKey(CONTEXT) && depth > 0)) { // LINE: 229
        this.prelude(collectPrefixes(((Map) obj).get(CONTEXT))); // LINE: 230
      }
      this.writeGraph(s, ((Map) obj).get(this.aliases.graph), depth); // LINE: 231
      return new ArrayList<>(); // LINE: 232
    }
    if (explicitList) { // LINE: 234
      this.write("( "); // LINE: 235
    }
    Boolean inGraph = (Boolean) ((viaKey == null && ((Object) this.aliases.graph) == null || viaKey != null && (viaKey).equals(this.aliases.graph)) && !(this.settings.turtleOnly)); // LINE: 237
    Integer inGraphAdd = (inGraph ? 1 : 0); // LINE: 238
    if ((s != null && this.hasKeys((Map) obj, 2))) { // LINE: 240
      if (depth == 0) { // LINE: 241
        this.writeln(); // LINE: 242
      }
      if (inGraphAdd > 0) { // LINE: 243
        this.write(this.getIndent(0)); // LINE: 244
      }
      this.write(this.refRepr(s)); // LINE: 245
    } else if (depth > 0) { // LINE: 246
      if (!(isBracketed)) { // LINE: 247
        depth += 1;
        this.write("["); // LINE: 249
      }
    } else {
      return new ArrayList<>(); // LINE: 251
    }
    String indent = this.getIndent(depth + inGraphAdd); // LINE: 253
    Integer nestedDepth = depth + 1 + inGraphAdd; // LINE: 255
    List<Map<String, Object>> topObjects = new ArrayList<>(); // LINE: 257
    Boolean first = true; // LINE: 259
    Boolean endedList = false; // LINE: 260
    for (Map.Entry<String, Object> key_vo : ((Map<String, Object>) obj).entrySet()) { // LINE: 262
      String key = key_vo.getKey();
      Object vo = key_vo.getValue();
      String term = (String) this.termFor(key); // LINE: 263
      /*@Nullable*/ String revKey = (term == null ? this.revKeyFor(key) : null); // LINE: 265
      if ((term == null && revKey == null)) { // LINE: 266
        continue; // LINE: 267
      }
      if (((term == null && ((Object) this.aliases.id) == null || term != null && (term).equals(this.aliases.id)) || (term == null && ((Object) CONTEXT) == null || term != null && (term).equals(CONTEXT)))) { // LINE: 269
        continue; // LINE: 270
      }
      if ((term == null && ((Object) this.aliases.index) == null || term != null && (term).equals(this.aliases.index))) { // LINE: 272
        continue; // LINE: 273
      }
      if ((term == null && ((Object) this.aliases.annotation) == null || term != null && (term).equals(this.aliases.annotation))) { // LINE: 275
        continue; // LINE: 276
      }
      List vs = (vo instanceof List ? (List) vo : (vo != null ? new ArrayList<>(Arrays.asList(new Object[] {(Object) vo})) : new ArrayList<>())); // LINE: 278
      vs = ((List) vs.stream().filter((x) -> x != null).collect(Collectors.toList())); // LINE: 279
      if (vs.size() == 0) { // LINE: 281
        continue; // LINE: 282
      }
      Boolean inList = (isList || this.isListContainer(key)); // LINE: 284
      /*@Nullable*/ Map<String, Object> revContainer = null; // LINE: 286
      if ((term == null && ((Object) this.aliases.reverse) == null || term != null && (term).equals(this.aliases.reverse))) { // LINE: 287
        revContainer = ((/*@Nullable*/ Map<String, Object>) ((Map) obj).get(key)); // LINE: 288
      } else if (revKey != null) { // LINE: 289
        revContainer = (Map<String, Object>) Builtins.mapOf(revKey, ((Map) obj).get(key)); // LINE: 290
      }
      if (revContainer != null) { // LINE: 292
        for (Map.Entry<String, Object> revkey_rvo : revContainer.entrySet()) { // LINE: 293
          String revkey = revkey_rvo.getKey();
          Object rvo = revkey_rvo.getValue();
          vs = (rvo instanceof List ? (List) rvo : (rvo != null ? new ArrayList<>(Arrays.asList(new Object[] {(Object) rvo})) : new ArrayList<>())); // LINE: 294
          for (Object x : vs) { // LINE: 295
            topObjects.add(this.makeTopObject(s, revkey, ((Map<String, Object>) x))); // LINE: 296
          }
        }
      } else {
        String useIndent = indent; // LINE: 300
        if (first) { // LINE: 301
          useIndent = " "; // LINE: 302
          first = false; // LINE: 303
        } else {
          if ((startedList && !(inList) && !(endedList))) { // LINE: 305
            endedList = true; // LINE: 306
            this.write(" )"); // LINE: 307
          }
          this.writeln(" ;"); // LINE: 308
        }
        assert term instanceof String;
        if ((term == null && ((Object) this.aliases.type) == null || term != null && (term).equals(this.aliases.type))) { // LINE: 312
          term = "a"; // LINE: 313
        }
        if (!term.equals(LIST)) { // LINE: 315
          term = (String) this.toValidTerm((String) term); // LINE: 316
          this.write(useIndent + term + " "); // LINE: 317
        }
        for (int i = 0; i < vs.size(); i++) { // LINE: 319
          Object v = (Object) vs.get(i); // LINE: 320
          if (inList) { // LINE: 322
            if (!(startedList)) { // LINE: 323
              this.write("("); // LINE: 324
              startedList = true; // LINE: 325
            }
            this.write(" "); // LINE: 326
          } else if (i > 0) { // LINE: 327
            if (this.settings.predicateRepeatNewLine) { // LINE: 328
              this.writeln(" ,"); // LINE: 329
              this.write(this.getIndent(nestedDepth)); // LINE: 330
            } else {
              this.write(" , "); // LINE: 332
            }
          }
          if ((this.bnodeSkolemBase != null && v instanceof Map && !((Map) v).containsKey(this.aliases.id))) { // LINE: 334
            s = (String) this.genSkolemId(); // LINE: 335
            ((Map) v).put(this.aliases.id, s); // LINE: 336
          }
          if ((term == null && ((Object) "a") == null || term != null && (term).equals("a"))) { // LINE: 338
            String t = (String) this.reprType(((Object) v)); // LINE: 339
            this.write(t); // LINE: 340
          } else if ((v != null && v instanceof Map && ((Map) v).containsKey(this.aliases.id))) { // LINE: 341
            topObjects.add((Map) v); // LINE: 342
            this.write(this.refRepr(((Map) v).get(this.aliases.id))); // LINE: 343
          } else if (v != null) { // LINE: 344
            List<Map<String, Object>> objects = this.writeObject(v, nestedDepth, key); // LINE: 345
            for (Map<String, Object> it : objects) { // LINE: 346
              topObjects.add(it); // LINE: 347
            }
          }
          this.writeAnnotation(v, depth); // LINE: 349
        }
      }
    }
    if ((explicitList || ((!(isList) && startedList) && !(endedList)))) { // LINE: 351
      this.write(" )"); // LINE: 352
    }
    if (depth == 0) { // LINE: 354
      if (!(first)) { // LINE: 355
        this.writeln(" ."); // LINE: 356
      }
      for (Map<String, Object> it : topObjects) { // LINE: 358
        this.writeObject(it, depth, viaKey); // LINE: 359
      }
      return new ArrayList<>(); // LINE: 360
    } else {
      indent = this.getIndent(nestedDepth - 1 + inGraphAdd); // LINE: 362
      if (this.settings.bracketEndNewLine) { // LINE: 363
        this.writeln(); // LINE: 364
        this.write(indent); // LINE: 365
      } else {
        this.write(" "); // LINE: 367
      }
      if (!(isBracketed)) { // LINE: 368
        this.write("]"); // LINE: 373
      }
      return topObjects; // LINE: 374
    }
  }

  public void writeAnnotation(Object v, Integer depth) { // LINE: 376
    if (this.settings.dropRdfstar) { // LINE: 377
      return; // LINE: 378
    }
    if ((v instanceof Map && ((Map) v).containsKey(this.aliases.annotation))) { // LINE: 380
      Map<String, Object> annotation = (Map<String, Object>) ((Map) v).get(this.aliases.annotation); // LINE: 381
      if (annotation != null) { // LINE: 382
        this.write(" {|"); // LINE: 383
        this.writeObject(annotation, depth + 2, this.aliases.annotation); // LINE: 384
        this.write("|}"); // LINE: 385
      }
    }
  }

  public void toLiteral(Object obj) {
    this.toLiteral(obj, null);
  }
  public void toLiteral(Object obj, /*@Nullable*/ String viaKey) {
    this.toLiteral(obj, viaKey, null);
  }
  public void toLiteral(Object obj, /*@Nullable*/ String viaKey, Function write) { // LINE: 387
    if (write == null) { // LINE: 393
      write = (s) -> this.write(s); // LINE: 394
    }
    Object value = obj; // LINE: 395
    /*@Nullable*/ Object lang = (/*@Nullable*/ Object) this.context.get(LANGUAGE); // LINE: 396
    /*@Nullable*/ String datatype = null; // LINE: 397
    if (obj instanceof Map) { // LINE: 398
      value = ((Map) obj).get(this.aliases.value); // LINE: 399
      datatype = ((String) ((Map) obj).get(this.aliases.type)); // LINE: 400
      lang = ((Map) obj).get(this.aliases.lang); // LINE: 401
    } else {
      /*@Nullable*/ Object kdef = null; // LINE: 403
      if ((viaKey != null && this.context.containsKey(viaKey))) { // LINE: 404
        kdef = ((Object) this.context.get(viaKey)); // LINE: 405
      }
      /*@Nullable*/ String coerceTo = null; // LINE: 406
      if ((kdef instanceof Map && ((Map) kdef).containsKey(TYPE))) { // LINE: 407
        coerceTo = ((String) ((Map) kdef).get(TYPE)); // LINE: 408
      }
      if ((coerceTo == null && ((Object) VOCAB) == null || coerceTo != null && (coerceTo).equals(VOCAB))) { // LINE: 409
        Boolean next = false; // LINE: 410
        for (Object v : asList(value)) { // LINE: 411
          if (next) { // LINE: 412
            write(" , "); // LINE: 413
          } else {
            next = true; // LINE: 415
          }
          write((v instanceof String ? this.refRepr((String) v, true) : this.toStr(v))); // LINE: 416
        }
        return; // LINE: 417
      } else if ((coerceTo == null && ((Object) ID) == null || coerceTo != null && (coerceTo).equals(ID))) { // LINE: 418
        Boolean next = false; // LINE: 419
        for (Object v : asList(value)) { // LINE: 420
          if (next) { // LINE: 421
            write(" , "); // LINE: 422
          } else {
            next = true; // LINE: 424
          }
          write(this.refRepr(v)); // LINE: 425
        }
        return; // LINE: 426
      } else if (coerceTo != null) { // LINE: 427
        datatype = coerceTo; // LINE: 428
      } else if ((kdef instanceof Map && ((Map) kdef).containsKey(LANGUAGE))) { // LINE: 430
        lang = ((Map) kdef).get(LANGUAGE); // LINE: 431
      }
    }
    Boolean next = false; // LINE: 433
    for (Object v : asList(value)) { // LINE: 434
      if (next) { // LINE: 435
        write(" , "); // LINE: 436
      } else {
        next = true; // LINE: 438
      }
      write(this.toStr(v, datatype, lang)); // LINE: 440
    }
  }

  public String toStr(Object v) {
    return this.toStr(v, null);
  }
  public String toStr(Object v, /*@Nullable*/ String datatype) {
    return this.toStr(v, datatype, null);
  }
  public String toStr(Object v, /*@Nullable*/ String datatype, /*@Nullable*/ Object lang) { // LINE: 442
    if (v instanceof String) { // LINE: 443
      List<String> parts = new ArrayList<>(); // LINE: 444
      String escaped = (String) ((String) v).replace("\\", "\\\\"); // LINE: 445
      String quote = "\""; // LINE: 446
      if (escaped.indexOf("\n") > -1) { // LINE: 447
        quote = "\"\"\""; // LINE: 448
        if (escaped.endsWith("\"")) { // LINE: 449
          escaped = escaped.substring(0, escaped.length() - 1) + "\\\""; // LINE: 450
        }
      } else {
        escaped = escaped.replace("\"", "\\\""); // LINE: 452
      }
      parts.add(quote); // LINE: 453
      parts.add(escaped); // LINE: 454
      parts.add(quote); // LINE: 455
      if (datatype != null) { // LINE: 456
        parts.add("^^" + this.toValidTerm(((String) this.termFor(datatype)))); // LINE: 457
      } else if (lang instanceof String) { // LINE: 458
        parts.add("@" + lang); // LINE: 459
      }
      return String.join("", parts); // LINE: 460
    } else if (v instanceof Boolean) { // LINE: 461
      return ((Boolean) v ? "true" : "false"); // LINE: 462
    } else {
      return v.toString(); // LINE: 464
    }
  }

  public /*@Nullable*/ String termFor(String key) { // LINE: 466
    if (key.startsWith("@")) { // LINE: 467
      return key; // LINE: 468
    } else if ((key.indexOf(":") > -1 || key.indexOf("/") > -1 || key.indexOf("#") > -1)) { // LINE: 469
      return key; // LINE: 472
    } else if (this.context.containsKey(key)) { // LINE: 473
      Object kdef = (Object) this.context.get(key); // LINE: 474
      if (kdef == null) { // LINE: 475
        return null; // LINE: 476
      }
      Object term = null; // LINE: 477
      if (kdef instanceof Map) { // LINE: 478
        term = ((Map) kdef).getOrDefault(ID, key); // LINE: 479
      } else {
        term = kdef; // LINE: 481
      }
      assert term instanceof String;
      Integer ci = (Integer) ((String) term).indexOf(":"); // LINE: 483
      return (ci == -1 ? ":" + term : (String) term); // LINE: 484
    } else {
      return ":" + key; // LINE: 486
    }
  }

  public /*@Nullable*/ String revKeyFor(String key) { // LINE: 488
    Object kdef = (Object) this.context.get(key); // LINE: 489
    if ((kdef instanceof Map && ((Map) kdef).containsKey(REVERSE))) { // LINE: 490
      return ((String) ((Map) kdef).get(REVERSE)); // LINE: 491
    }
    return null; // LINE: 492
  }

  public Map<String, Object> makeTopObject(/*@Nullable*/ String s, String revKey, Map it) { // LINE: 494
    Map node = new HashMap(it); // LINE: 495
    if (!node.containsKey(this.aliases.id)) { // LINE: 497
      node.put(this.aliases.id, "_:bnode-" + this.bnodeCounter); // LINE: 498
      this.bnodeCounter += 1;
    }
    node.put(revKey, Builtins.mapOf(this.aliases.id, s)); // LINE: 500
    return node; // LINE: 501
  }

  public String reprType(Object t) { // LINE: 503
    String tstr = (String) (t instanceof String ? (String) t : ((String) ((Map) t).get(TYPE))); // LINE: 504
    return this.toValidTerm(((String) this.termFor(tstr))); // LINE: 505
  }

  public String refRepr(/*@Nullable*/ Object refobj) {
    return this.refRepr(refobj, false);
  }
  public String refRepr(/*@Nullable*/ Object refobj, Boolean useVocab) { // LINE: 507
    if (refobj == null) { // LINE: 508
      return "[]"; // LINE: 509
    }
    if ((refobj instanceof Map && ((Map) refobj).containsKey(this.aliases.id))) { // LINE: 511
      return this.reprTriple((Map) refobj); // LINE: 512
    }
    String ref = (String) ((String) refobj); // LINE: 514
    Integer c_i = (Integer) ref.indexOf(":"); // LINE: 516
    if (c_i > -1) { // LINE: 517
      String pfx = ref.substring(0, c_i); // LINE: 518
      if ((pfx == null && ((Object) "_") == null || pfx != null && (pfx).equals("_"))) { // LINE: 519
        String nodeId = ref + this.uniqueBnodeSuffix; // LINE: 520
        if (this.bnodeSkolemBase != null) { // LINE: 521
          ref = this.bnodeSkolemBase + nodeId.substring(2); // LINE: 522
        } else {
          return this.toValidTerm(nodeId); // LINE: 524
        }
      } else if (this.context.containsKey(pfx)) { // LINE: 525
        String local = ref.substring(c_i + 1); // LINE: 526
        return pfx + ":" + this.escapePnameLocal(local); // LINE: 527
      }
    } else if ((useVocab && ref.indexOf("/") == -1)) { // LINE: 528
      return ":" + ref; // LINE: 529
    }
    if ((this.context.containsKey(VOCAB) && ref.startsWith(((String) this.context.get(VOCAB))))) { // LINE: 531
      return ":" + ref.substring(((String) this.context.get(VOCAB)).length()); // LINE: 532
    }
    ref = (String) this.cleanValue(ref); // LINE: 534
    c_i = (Integer) ref.indexOf(":"); // LINE: 536
    if (c_i > -1) { // LINE: 537
      String pfx = ref.substring(0, c_i); // LINE: 538
      String rest = (String) ref.substring(c_i); // LINE: 539
      if (this.context.containsKey(pfx)) { // LINE: 540
        return ref; // LINE: 541
      }
      if ((this.context.size() > 0 && rest.indexOf(":") == -1 && (WORD_START.matcher(rest).matches() ? rest : null) != null && (WORD_START.matcher(pfx).matches() ? pfx : null) != null)) { // LINE: 543
        return ref; // LINE: 547
      }
    }
    return "<" + ref + ">"; // LINE: 549
  }

  public String reprTriple(Map<String, Object> ref) { // LINE: 551
    if (this.settings.dropRdfstar) { // LINE: 552
      throw new RuntimeException("Triple nodes disallowed unless in RDF-star mode"); // LINE: 553
    }
    String s = (String) this.refRepr(((String) ref.get(this.aliases.id))); // LINE: 555
    String p = ""; // LINE: 557
    Object obj = ""; // LINE: 558
    for (String k : ref.keySet()) { // LINE: 559
      if ((k == null && ((Object) this.aliases.id) == null || k != null && (k).equals(this.aliases.id))) { // LINE: 560
        continue; // LINE: 561
      }
      if (!p.equals("")) { // LINE: 562
        throw new RuntimeException("Quoted triples cannot contain multiple statements"); // LINE: 563
      }
      p = ((String) this.termFor(k)); // LINE: 565
      obj = ((Map<String, Object>) ref.get(k)); // LINE: 566
    }
    String o; // LINE: 568
    if ((p == null && ((Object) this.aliases.type) == null || p != null && (p).equals(this.aliases.type))) { // LINE: 569
      p = "a"; // LINE: 570
      o = (String) this.reprType(obj); // LINE: 571
    } else {
      if (obj instanceof List) { // LINE: 573
        throw new RuntimeException("Quoted triples must have one single object"); // LINE: 574
      }
      if ((this.isLangContainer(p) && obj instanceof Map)) { // LINE: 575
        throw new RuntimeException("Language containers not yet supported in quoted triples"); // LINE: 576
      }
      if ((obj instanceof Map && ((Map) obj).containsKey(this.aliases.list))) { // LINE: 577
        throw new RuntimeException("Quoted triples cannot contain Lists"); // LINE: 578
      }
      if ((!(obj instanceof Map) || ((Map) obj).containsKey(this.aliases.value))) { // LINE: 580
        List<String> l = new ArrayList<>(); // LINE: 581
        this.toLiteral((Map) obj, p, (x) -> l.add(((String) x))); // LINE: 582
        o = String.join("", l); // LINE: 583
      } else {
        assert (obj instanceof Map && ((Map) obj).containsKey(this.aliases.id));
        o = (String) this.refRepr(((String) ((Map) obj).get(this.aliases.id))); // LINE: 586
      }
    }
    return "<< " + s + " " + p + " " + o + " >>"; // LINE: 588
  }

  public String toValidTerm(String term) { // LINE: 590
    term = (String) this.cleanValue(term); // LINE: 591
    Integer c_i = (Integer) term.indexOf(":"); // LINE: 592
    /*@Nullable*/ String pfx = (c_i > -1 ? term.substring(0, c_i) : null); // LINE: 593
    if ((!(this.context.containsKey(pfx)) && (term.indexOf("/") > -1 || term.indexOf("#") > -1 || (pfx != null && term.lastIndexOf(":") > pfx.length())))) { // LINE: 594
      return "<" + term + ">"; // LINE: 601
    }
    if (pfx != null) { // LINE: 602
      String local = term.substring(c_i + 1); // LINE: 603
      return pfx + ":" + this.escapePnameLocal(local); // LINE: 604
    }
    return this.escapePnameLocal(term); // LINE: 605
  }

  public boolean hasKeys(Map<String, Object> obj) {
    return this.hasKeys(obj, 1);
  }
  public boolean hasKeys(Map<String, Object> obj, Integer atLeast) { // LINE: 607
    Integer seen = 0; // LINE: 608
    for (String k : obj.keySet()) { // LINE: 609
      if (!k.equals(this.aliases.annotation)) { // LINE: 610
        seen += 1;
        if ((seen == null && ((Object) atLeast) == null || seen != null && (seen).equals(atLeast))) { // LINE: 612
          return true; // LINE: 613
        }
      }
    }
    return false; // LINE: 614
  }

  public String cleanValue(String v) { // LINE: 616
    return v; // LINE: 617
  }

  public String escapePnameLocal(String pnlocal) { // LINE: 619
    return (PNAME_LOCAL_ESC.matcher(pnlocal).replaceAll("\\\\$1")); // LINE: 623
  }

  public /*@Nullable*/ String genSkolemId() { // LINE: 625
    if (this.bnodeSkolemBase == null) { // LINE: 626
      return null; // LINE: 627
    }
    return this.bnodeSkolemBase + uuid4(); // LINE: 628
  }

  public String getIndent(Integer depth) { // LINE: 630
    List<String> chunks = new ArrayList<>(); // LINE: 631
    Integer i = -1; // LINE: 632
    while (i < depth) { // LINE: 633
      i += 1;
      chunks.add(this.settings.indentChars); // LINE: 635
    }
    return String.join("", chunks); // LINE: 636
  }

  public void write(String s) { // LINE: 638
    this.out.write((s != null ? s : "")); // LINE: 639
  }

  public void writeln() {
    this.writeln(null);
  }
  public void writeln(/*@Nullable*/ String s) { // LINE: 641
    this.out.write((s != null ? s : "") + "\n"); // LINE: 642
  }

  protected /*@Nullable*/ String write(Object s) { // LINE: 645
    this.write(((String) s)); // LINE: 646
    return null; // LINE: 647
  }
}
