/**
 * This file was automatically generated by the TRLD transpiler.
 * Source: trld/tvm/mapmaker.py
 */
package trld.tvm;

//import javax.annotation.Nullable;
import java.util.*;
import java.util.function.Function;
import java.util.regex.Pattern;
import java.util.stream.Stream;
import java.util.stream.Collectors;
import java.io.*;

import trld.Builtins;
import trld.KeyValue;

import static trld.jsonld.Base.CONTEXT;
import static trld.jsonld.Base.GRAPH;
import static trld.jsonld.Base.ID;
import static trld.jsonld.Base.LIST;
import static trld.jsonld.Base.REVERSE;
import static trld.jsonld.Base.TYPE;
import static trld.jsonld.Base.VOCAB;
import static trld.jsonld.Base.asList;
import static trld.jsonld.extras.Index.makeIndex;

public class Mapmaker {
  public static final String RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#"; // LINE: 9
  static String RDF_Property = RDF + "Property"; // LINE: 10
  static String RDF_Statement = RDF + "Statement"; // LINE: 11
  static String RDF_subject = RDF + "subject"; // LINE: 12
  static String RDF_predicate = RDF + "predicate"; // LINE: 13
  static String RDF_object = RDF + "object"; // LINE: 14
  public static final String RDFS = "http://www.w3.org/2000/01/rdf-schema#"; // LINE: 16
  static String RDFS_Class = RDFS + "Class"; // LINE: 17
  static String RDFS_subClassOf = RDFS + "subClassOf"; // LINE: 18
  static String RDFS_subPropertyOf = RDFS + "subPropertyOf"; // LINE: 19
  static String RDFS_domain = RDFS + "domain"; // LINE: 20
  static String RDFS_range = RDFS + "range"; // LINE: 21
  public static final String OWL = "http://www.w3.org/2002/07/owl#"; // LINE: 23
  static String OWL_Class = OWL + "Class"; // LINE: 24
  static String OWL_Datatype = OWL + "Datatype"; // LINE: 25
  static String OWL_ObjectProperty = OWL + "ObjectProperty"; // LINE: 26
  static String OWL_DatatypeProperty = OWL + "DatatypeProperty"; // LINE: 27
  static String OWL_Restriction = OWL + "Restriction"; // LINE: 28
  static String OWL_equivalentClass = OWL + "equivalentClass"; // LINE: 29
  static String OWL_equivalentProperty = OWL + "equivalentProperty"; // LINE: 30
  static String OWL_inverseOf = OWL + "inverseOf"; // LINE: 31
  static String OWL_propertyChainAxiom = OWL + "propertyChainAxiom"; // LINE: 32
  static String OWL_onProperty = OWL + "onProperty"; // LINE: 33
  static String OWL_hasValue = OWL + "hasValue"; // LINE: 34
  static String OWL_allValuesFrom = OWL + "allValuesFrom"; // LINE: 35
  public static final String SKOS = "http://www.w3.org/2004/02/skos/core#"; // LINE: 37
  static String SKOS_broadMatch = SKOS + "broadMatch"; // LINE: 38
  static String SKOS_closeMatch = SKOS + "closeMatch"; // LINE: 39
  static String SKOS_exactMatch = SKOS + "exactMatch"; // LINE: 40
  static String SKOS_narrowMatch = SKOS + "narrowMatch"; // LINE: 41
  static String SKOS_mappingRelation = SKOS + "mappingRelation"; // LINE: 42
  public static final Set<String> SYMMETRIC = new HashSet(new ArrayList<>(Arrays.asList(new String[] {(String) OWL_equivalentClass, OWL_equivalentProperty, SKOS_closeMatch, SKOS_exactMatch}))); // LINE: 44

  public static Map makeTargetMap(Object vocab, Object target) { // LINE: 61
    Map<String, Object> targetDfn = new LinkedHashMap(); // LINE: 62
    if (target instanceof String) { // LINE: 63
      targetDfn.put(VOCAB, (String) target); // LINE: 64
    } else {
      if (target instanceof Map) { // LINE: 66
        target = ((Map) target).get(CONTEXT); // LINE: 67
      }
      for (Object dfn : asList(target)) { // LINE: 68
        targetDfn.putAll(((Map) dfn)); // LINE: 69
      }
    }
    List<Map<String, Object>> graph = (List<Map<String, Object>>) (vocab instanceof List ? (List) vocab : ((List) ((Map) vocab).get(GRAPH))); // LINE: 71
    Map<String, Map<String, Object>> vocabIndex = (Map<String, Map<String, Object>>) makeIndex(graph); // LINE: 73
    Map<String, Object> targetMap = new HashMap<>(); // LINE: 75
    for (Map<String, Object> obj : graph) { // LINE: 77
      /*@Nullable*/ String id = ((/*@Nullable*/ String) obj.get(ID)); // LINE: 78
      processClassRelations(obj, vocabIndex, targetDfn, targetMap); // LINE: 80
      processPropertyRelations(obj, vocabIndex, targetDfn, targetMap); // LINE: 82
      processReifiedForms(obj, vocabIndex, targetMap); // LINE: 84
    }
    for (Map.Entry<String, Object> key_rule : targetMap.entrySet()) { // LINE: 86
      String key = key_rule.getKey();
      Object rule = key_rule.getValue();
      List<Map.Entry<Integer, Object>> rules = (List<Map.Entry<Integer, Object>>) Builtins.sorted(asList(rule), (it) -> new KeyValue(((Integer) ((Map.Entry) it).getKey()), (((Map.Entry) it).getValue() instanceof Map ? ((Map) ((Map.Entry) it).getValue()).get("match") != null : false)), true); // LINE: 87
      targetMap.put(key, rules.stream().map((priority_it) -> priority_it.getValue()).collect(Collectors.toList())); // LINE: 94
    }
    return targetMap; // LINE: 96
  }

  protected static void processClassRelations(Map obj, Map vocabIndex, Map<String, Object> target, Map targetMap) { // LINE: 99
    List<String> rels = new ArrayList<>(Arrays.asList(new String[] {(String) OWL_equivalentClass, RDFS_subClassOf})); // LINE: 100
    List<BaseRelation> baseRels = new ArrayList<>(); // LINE: 103
    /*@Nullable*/ String id = ((/*@Nullable*/ String) obj.get(ID)); // LINE: 105
    Integer idTargetPrio = 0; // LINE: 107
    if (id != null) { // LINE: 108
      idTargetPrio = getTargetPriority(target, id); // LINE: 109
      if (idTargetPrio > 0) { // LINE: 110
        baseRels.add(new BaseRelation(null, id, idTargetPrio)); // LINE: 111
      }
    }
    List<Map.Entry</*@Nullable*/ String, Map>> candidates = collectCandidates(obj, rels); // LINE: 113
    Set<String> seenCandidates = new HashSet(); // LINE: 115
    while ((candidates != null && candidates.size() > 0)) { // LINE: 117
      Map.Entry<String, Map> crel_candidate = candidates.remove(0); // LINE: 118
      String crel = crel_candidate.getKey();
      Map candidate = crel_candidate.getValue();
      if (!candidate.containsKey(ID)) { // LINE: 119
        continue; // LINE: 120
      }
      String candidateId = (String) candidate.get(ID); // LINE: 121
      candidate = ((Map) vocabIndex.getOrDefault(candidateId, candidate)); // LINE: 122
      Integer targetPrio = getTargetPriority(target, candidateId); // LINE: 124
      if (targetPrio > 0) { // LINE: 125
        baseRels.add(new BaseRelation(crel, candidateId, targetPrio)); // LINE: 126
      } else if ((SYMMETRIC.contains(crel) && idTargetPrio > 0)) { // LINE: 127
        assert id != null;
        addRule(targetMap, candidateId, id, idTargetPrio); // LINE: 129
      } else if (!seenCandidates.contains(candidateId)) { // LINE: 130
        extendCandidates(candidates, candidate, rels); // LINE: 131
      }
      seenCandidates.add(candidateId); // LINE: 133
    }
    if ((id != null && idTargetPrio == 0)) { // LINE: 135
      baseRels = baseRels.stream().filter((it) -> !it.base.equals(id)).collect(Collectors.toList()); // LINE: 136
      if (baseRels.size() > 0) { // LINE: 138
        List<String> baseClasses = new ArrayList<>(); // LINE: 139
        for (BaseRelation baserel : baseRels) { // LINE: 140
          /*@Nullable*/ Map classDfn = ((/*@Nullable*/ Map) vocabIndex.get(baserel.base)); // LINE: 141
          if (classDfn == null) { // LINE: 142
            classDfn = Builtins.mapOf(ID, baserel.base); // LINE: 143
          }
          baseClasses.add(((String) classDfn.get(ID))); // LINE: 144
          break; // LINE: 145
        }
        addRule(targetMap, id, baseClasses); // LINE: 148
      }
    }
  }

  protected static void processPropertyRelations(Map obj, Map vocabIndex, Map<String, Object> target, Map targetMap) { // LINE: 151
    List<String> rels = new ArrayList<>(Arrays.asList(new String[] {(String) OWL_equivalentProperty, RDFS_subPropertyOf})); // LINE: 152
    if (!obj.containsKey(ID)) { // LINE: 154
      return; // LINE: 155
    }
    String id = (String) obj.get(ID); // LINE: 157
    Integer idTargetPrio = getTargetPriority(target, id); // LINE: 158
    /*@Nullable*/ String property = (idTargetPrio > 0 ? id : null); // LINE: 159
    Integer propPrio = idTargetPrio; // LINE: 160
    if (property != null) { // LINE: 163
      addRule(targetMap, id, property, idTargetPrio); // LINE: 164
    }
    List<Map.Entry</*@Nullable*/ String, Map>> candidates = collectCandidates(obj, rels); // LINE: 166
    List<Map.Entry<Integer, String>> baseprops = new ArrayList<>(); // LINE: 168
    if (idTargetPrio > 0) { // LINE: 169
      baseprops.add(new KeyValue(idTargetPrio, id)); // LINE: 170
    }
    /*@Nullable*/ String candidateProp = null; // LINE: 172
    while ((candidates != null && candidates.size() > 0)) { // LINE: 174
      Map.Entry<String, Map> crel_candidate = candidates.remove(0); // LINE: 175
      String crel = crel_candidate.getKey();
      Map candidate = crel_candidate.getValue();
      if (!candidate.containsKey(ID)) { // LINE: 176
        continue; // LINE: 177
      }
      String candidateId = (String) candidate.get(ID); // LINE: 178
      candidate = ((Map) vocabIndex.getOrDefault(candidateId, candidate)); // LINE: 179
      Integer targetPrio = getTargetPriority(target, candidateId); // LINE: 181
      if ((idTargetPrio == 0 && targetPrio > 0)) { // LINE: 182
        baseprops.add(new KeyValue(targetPrio, candidateId)); // LINE: 183
        addRule(targetMap, id, candidateId, targetPrio); // LINE: 184
        candidateProp = candidateId; // LINE: 185
        propPrio = targetPrio; // LINE: 186
      } else if ((SYMMETRIC.contains(crel) && targetPrio == 0 && idTargetPrio > 0)) { // LINE: 188
        addRule(targetMap, candidateId, id, idTargetPrio); // LINE: 189
        candidateProp = candidateId; // LINE: 190
        propPrio = targetPrio; // LINE: 191
      } else {
        extendCandidates(candidates, candidate, rels); // LINE: 194
      }
    }
    processPropertyChain(obj, target, targetMap, candidateProp, baseprops); // LINE: 196
  }

  protected static boolean processPropertyChain(Map obj, Map<String, Object> target, Map targetMap, /*@Nullable*/ String candidateProp, List<Map.Entry<Integer, String>> baseprops) { // LINE: 199
    if (!obj.containsKey(OWL_propertyChainAxiom)) { // LINE: 204
      return false; // LINE: 205
    }
    List<Map> propChain = ((List<Map>) obj.get(OWL_propertyChainAxiom)); // LINE: 207
    /*@Nullable*/ String sourceProperty = null; // LINE: 208
    List<Map> lst = (List<Map>) propChain.get(0).get(LIST); // LINE: 210
    Map lead = (Map) lst.get(0); // LINE: 211
    if (lead != null) { // LINE: 213
      sourceProperty = (String) lead.get(ID); // LINE: 214
    }
    String valueFrom = (String) lst.get(1).get(ID); // LINE: 216
    /*@Nullable*/ String rtype = null; // LINE: 217
    if ((sourceProperty == null || sourceProperty.startsWith("_:"))) { // LINE: 220
      try { // LINE: 221
        List<Map> ranges = (List<Map>) lead.get(RDFS_range); // LINE: 222
        rtype = (String) ranges.get(0).get(ID); // LINE: 223
      } catch (Exception e) { // LINE: 224
      }
      List<Map> superprops = (List<Map>) lead.get(RDFS_subPropertyOf); // LINE: 226
      sourceProperty = (String) superprops.get(0).get(ID); // LINE: 227
    }
    /*@Nullable*/ Map match = (rtype != null ? Builtins.mapOf(TYPE, rtype) : null); // LINE: 229
    if (sourceProperty != null) { // LINE: 233
      if ((!sourceProperty.equals(candidateProp) && getTargetPriority(target, sourceProperty) == 0)) { // LINE: 234
        for (Map.Entry<Integer, String> prio_baseprop : baseprops) { // LINE: 236
          Integer prio = prio_baseprop.getKey();
          String baseprop = prio_baseprop.getValue();
          Map rule = ruleFrom(baseprop, null, valueFrom, match); // LINE: 237
          addRule(targetMap, sourceProperty, rule, prio); // LINE: 238
        }
        return true; // LINE: 240
      }
    }
    return false; // LINE: 244
  }

  protected static List<Map.Entry</*@Nullable*/ String, Map>> collectCandidates(Map obj, List<String> rels) { // LINE: 247
    List<Map.Entry</*@Nullable*/ String, Map>> candidates = new ArrayList<>(); // LINE: 248
    for (String rel : rels) { // LINE: 249
      Object refs = (Object) obj.get(rel); // LINE: 250
      if (refs instanceof List) { // LINE: 251
        candidates.addAll(((List<Map.Entry</*@Nullable*/ String, Map>>) ((List) refs).stream().map((ref) -> new KeyValue(rel, ref)).collect(Collectors.toList())));
      }
    }
    return candidates; // LINE: 253
  }

  protected static void extendCandidates(List<Map.Entry</*@Nullable*/ String, Map>> candidates, Map candidate, List<String> rels) { // LINE: 256
    for (String rel : rels) { // LINE: 257
      /*@Nullable*/ List<Map> superrefs = ((/*@Nullable*/ List<Map>) candidate.get(rel)); // LINE: 258
      if (superrefs != null) { // LINE: 259
        for (Map sup : superrefs) { // LINE: 260
          if (sup.containsKey(ID)) { // LINE: 261
            candidates.add(new KeyValue(null, sup)); // LINE: 262
          }
        }
      }
    }
  }

  protected static void processReifiedForms(Map obj, Map vocabIndex, Map<String, Object> targetMap) { // LINE: 265
    /*@Nullable*/ Map prop = traceInverseOfSubject(obj, vocabIndex); // LINE: 266
    if (prop != null) { // LINE: 268
      List<Map> ranges = new ArrayList<>(); // LINE: 269
      String propId = (String) obj.get(ID); // LINE: 271
      if (obj.containsKey(RDFS_range)) { // LINE: 273
        ranges.addAll(asList(obj.get(RDFS_range)));
      }
      if ((prop != obj && prop.containsKey(RDFS_range))) { // LINE: 275
        ranges.addAll(asList(prop.get(RDFS_range)));
      }
      /*@Nullable*/ String propertyFrom = null; // LINE: 278
      /*@Nullable*/ String valueFrom = null; // LINE: 279
      for (Map range : ranges) { // LINE: 281
        /*@Nullable*/ Map rangeNode = (/*@Nullable*/ Map) vocabIndex.get(range.get(ID)); // LINE: 282
        if (rangeNode == null) { // LINE: 283
          continue; // LINE: 284
        }
        /*@Nullable*/ Map reverses = (/*@Nullable*/ Map) ((Map) rangeNode.get(REVERSE)); // LINE: 285
        List<Map> inDomainOf = (reverses != null ? ((List<Map>) reverses.getOrDefault(RDFS_domain, new ArrayList<>())) : new ArrayList<>()); // LINE: 286
        for (Map domainProp : inDomainOf) { // LINE: 287
          if (leadsTo(domainProp, vocabIndex, RDFS_subPropertyOf, RDF_predicate)) { // LINE: 288
            propertyFrom = (String) domainProp.get(ID); // LINE: 289
          } else if (leadsTo(domainProp, vocabIndex, RDFS_subPropertyOf, RDF_object)) { // LINE: 290
            valueFrom = (String) domainProp.get(ID); // LINE: 291
          }
        }
      }
      if ((propertyFrom != null && valueFrom != null && propId instanceof String)) { // LINE: 293
        addRule(targetMap, (String) propId, ruleFrom(null, propertyFrom, valueFrom, null)); // LINE: 294
      }
    }
  }

  protected static /*@Nullable*/ Map traceInverseOfSubject(Map obj, Map vocabIndex) { // LINE: 297
    /*@Nullable*/ List<Map> invs = ((/*@Nullable*/ List<Map>) obj.get(OWL_inverseOf)); // LINE: 298
    if (invs != null) { // LINE: 300
      for (Map p : invs) { // LINE: 301
        if (leadsTo(p, vocabIndex, RDFS_subPropertyOf, RDF_subject)) { // LINE: 302
          return p; // LINE: 303
        }
      }
    }
    /*@Nullable*/ List<Map> supers = ((/*@Nullable*/ List<Map>) obj.get(RDFS_subPropertyOf)); // LINE: 305
    if (supers == null) { // LINE: 306
      return null; // LINE: 307
    }
    for (Map supref : supers) { // LINE: 309
      Map sup = (Map) ((Map) (supref.containsKey(ID) ? vocabIndex.getOrDefault(supref.get(ID), supref) : supref)); // LINE: 310
      if (traceInverseOfSubject(sup, vocabIndex) != null) { // LINE: 311
        return sup; // LINE: 312
      }
    }
    return null; // LINE: 314
  }

  protected static void addRule(Map<String, Object> targetMap, String sourceId, Object rule) {
    addRule(targetMap, sourceId, rule, 0);
  }
  protected static void addRule(Map<String, Object> targetMap, String sourceId, Object rule, Integer priority) { // LINE: 317
    if ((sourceId == null && ((Object) rule) == null || sourceId != null && (sourceId).equals(rule))) { // LINE: 321
      return; // LINE: 322
    }
    Object rulePriority = (Object) (rule instanceof List ? ((List) rule).stream().map((it) -> new KeyValue(priority, it)).collect(Collectors.toList()) : new ArrayList<>(Arrays.asList(new Object[] {(Object) new KeyValue(priority, rule)}))); // LINE: 324
    List rules = (List) ((List) targetMap.get(sourceId)); // LINE: 326
    if (rules == null) { // LINE: 327
      targetMap.put(sourceId, rulePriority); // LINE: 328
    } else {
      if (!(rules instanceof List)) { // LINE: 330
        rules = new ArrayList<>(Arrays.asList(new List[] {(List) rules})); // LINE: 331
        targetMap.put(sourceId, rules); // LINE: 332
      }
      if (rulePriority instanceof List) { // LINE: 333
        rules.addAll((List) rulePriority);
      } else {
        ((List) rules).add(rulePriority); // LINE: 336
      }
    }
  }

  protected static Map ruleFrom(/*@Nullable*/ String property, /*@Nullable*/ String propertyFrom, /*@Nullable*/ String valueFrom, /*@Nullable*/ Map<String, String> match) { // LINE: 339
    return Builtins.mapOf("property", property, "propertyFrom", propertyFrom, "valueFrom", valueFrom, "match", match); // LINE: 343
  }

  protected static Integer getTargetPriority(Map<String, Object> target, String id) { // LINE: 351
    Integer topPrio = (Integer) target.size(); // LINE: 352
    Integer prio = topPrio * 3; // LINE: 354
    for (Object v : target.values()) { // LINE: 355
      if ((id == null && ((Object) v) == null || id != null && (id).equals(v))) { // LINE: 356
        return prio; // LINE: 357
      }
      prio -= 1;
    }
    if ((target.containsKey(VOCAB) && id.startsWith(((String) target.get(VOCAB))))) { // LINE: 360
      return topPrio * 2; // LINE: 361
    }
    prio = topPrio; // LINE: 363
    for (Object v : target.values()) { // LINE: 364
      if ((v instanceof String && id.startsWith(((String) v)))) { // LINE: 365
        return prio; // LINE: 366
      }
      prio -= 1;
    }
    return 0; // LINE: 369
  }

  public static boolean leadsTo(Map s, Map vocabIndex, String rel, Object o) { // LINE: 372
    if ((s.get(ID) == null && ((Object) o) == null || s.get(ID) != null && (s.get(ID)).equals(o))) { // LINE: 373
      return true; // LINE: 374
    }
    /*@Nullable*/ Map data = (/*@Nullable*/ Map) ((Map) (s.containsKey(ID) ? vocabIndex.getOrDefault(s.get(ID), s) : s)); // LINE: 376
    List<Map> xs = (List<Map>) (data != null ? ((List) data.getOrDefault(rel, new ArrayList<>())) : new ArrayList<>()); // LINE: 377
    for (Map x : xs) { // LINE: 379
      if (((x.get(ID) == null && ((Object) o) == null || x.get(ID) != null && (x.get(ID)).equals(o)) || leadsTo(x, vocabIndex, rel, o))) { // LINE: 380
        return true; // LINE: 381
      }
    }
    return false; // LINE: 383
  }
}
